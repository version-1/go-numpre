import { describe, expect, test } from "vitest";
import { stringToGrid, solve, validate } from "./lib.mjs";

describe("#solve", () => {
  const list = [
    "000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "031702864607081030008900100302640000185070603096000050720103508009024017000590400",
    "100097000000000576427806900000900035000060000509040002004630800008010700902085000",
    "600030000000009060500000109000702003200080600430000801305204000000600070040007000",
    "013609700000000040090000000000400601080100200000007050002001087705000004000040000",
    "000000000830010400000070800904030100005940060000005020060000000400800000209000710",
    "000000000830010400000070800904030100005940060000005020060000000400800000209000710",
    "400009500290750000503000004000030020600007080040200005000000000376400000000080607",
  ];

  for (let i = 0; i < list.length; i++) {
    const str = list[i];
    test(`Q${i + 1}`, () => {
      const grid = stringToGrid(str);
      solve(grid);
      expect(validate(grid)).toBe(undefined);
    });
  }
});

describe("#validate", () => {
  const input =
    "123456789123456789123456789123456789123456789123456789123456789123456789123456789";
  test(`return impossible position`, () => {
    const grid = stringToGrid(input);
    expect(validate(grid)).toEqual({ x: 0, y: 0, n: 1 });
  });

  describe("includes zero", () => {
    const input =
      "123456789456789123789120456214365897365897214897214365531642978642978531978531642";
    test(`return zero position`, () => {
      const grid = stringToGrid(input);
      expect(validate(grid)).toEqual({ x: 2, y: 5, n: 0 });
    });
  });
});
